section .data
    numbers db 4, 101, 32, 21, 112, 332, 22, 67 ; Инициализация массива чисел
    len equ $-numbers ; Вычисление длины массива

section .bss
    sum resb 1 ; Резервирование байта для хранения суммы
    buffer resb 10 ; Резервирование буфера для преобразования числа в строку

section .text
    global _start

_start:
    mov eax, 0 ; Инициализация суммы
    mov ecx, len ; Инициализация счетчика

loop:
    dec ecx ; Уменьшение счетчика
    movzx ebx, byte [numbers+ecx] ; Получение очередного числа из массива
    test bl, 1 ; Проверка числа на нечетность
    jz next ; Если число четное, переход к следующему числу
    test ecx, 1 ; Проверка позиции числа на нечетность
    jz next ; Если позиция четная, переход к следующему числу
    add eax, ebx ; Добавление числа к сумме

next:
    cmp ecx, 0 ; Проверка достижения начала массива
    jne loop ; Если не достигнут конец, переход к следующему числу

    mov [sum], al ; Сохранение суммы в памяти

    ; Преобразование суммы в строку
    mov eax, [sum]
    call int_to_string

    ; Вывод суммы на экран
    mov eax, 1 ; Системный вызов для write
    mov edi, 1 ; Дескриптор файла (stdout)
    mov esi, buffer ; Адрес буфера для вывода
    mov edx, 10 ; Длина буфера
    syscall

    ; Завершение программы
    mov eax, 60 ; Системный вызов для exit
    xor edi, edi ; Код возврата 0
    syscall

int_to_string:
    mov ecx, 10 ; База системы счисления
    mov edi, buffer + 9 ; Указатель на конец буфера
    mov byte [edi], 0 ; Завершающий символ

convert_loop:
    xor edx, edx ; Очистка edx для деления
    div ecx ; Деление eax на 10
    add dl, '0' ; Преобразование остатка в символ
    dec edi ; Перемещение указателя на предыдущую позицию
    mov [edi], dl ; Сохранение символа в буфер
    test eax, eax ; Проверка, что делимое не равно 0
    jnz convert_loop ; Если не равно 0, продолжение конвертации

    mov eax, edi ; Возврат указателя на начало строки
    ret
